\chapter{Introduction}

\section{Motivation}
To test the reliability of a numerical method or an approximation, e.g. such as in \cite{B_bachelor_thesis}, an implementation in python is sufficient. Python is easy to understand and the code can also be used as a base e.g. for a C++ version. A python framework to solve the time-dependent Schr\"odinger equation with a semiclassical approach with \textit{Hagedorn} wavepackets is already availabla on github \cite{waveblocksnd}. This can be used for example to test different propagation schemes, integration methods or integration partitions. In case longer simulations or solving higher dimensional problems is desired the execution time could increase rapidly in a python implementation. Therefore it is necessary to port the python implementation to C or C++ which are highly time efficient. The core implementation is already available in C++ on github \cite{libwaveblocks} but further improvement is desired. This implementation currently uses an external project \cite{eigen3-hdf5} for writing data in HDF5 format. This project is sufficient if the user supervises the generated data. The goal of this project is to use the HDF5 interface \cite{hdf5cppdoc} directly to write data in a comparable way to python. This further allows to implement a data test which can compare data files between python and C++. This was done with the well-known \textit{GoogleTest} \cite{googletest} framework.

\section{Background}
\label{seq:background}

In quantum physics the most prominent problems are governed by the time-dependent
Schr\"odinger equation \ref{eq:basics_tdse_simple}

\begin{equation} \label{eq:basics_tdse_simple}
  i \hbar \frac{\partial}{\partial t} \Ket{\varphi} = H \Ket{\varphi}
\end{equation}

where $H$ is the Hamiltonian, $\varphi(x,t)$ represents the wave function dependent on position $x$ and
time $t$ and $\langle \varphi | \varphi  \rangle$ is the probability density of electrons. This equation can be reformulated in a semiclassical setting for nuclei as: \
\begin{equation}
\label{eq:tdse_sc_nuclei}
 i\hbar \partial_{t}\psi = \left( -\frac{\hbar^{2}}{2} \Delta_{x} + V(\vec{x}) \right) \psi\,.
\end{equation}
Nevertheless there are still much challenges involved to solve this equation \ref{eq:tdse_sc_nuclei}. One of this is the high dimensionality of this equation. A molecule with $N$ nuclei where each of them has three degrees of freedom results in $3N$ unknowns. For example the simple molecule $\mathrm{CO_{2}}$ has already $d=9$ degrees of freedom. Another challenge is the multiple scales governed by the small parameter $\hbar = \varepsilon^{2}$ in case of $\mathrm{CO_{2}}$ it results in $\hbar \approx 0.0058$. Also the actual solution has frequencies of order $1/\hbar$ which are hard to reproduce for small $\hbar$ on a finite uniform grid as required by a Fourier based approach. Further there is the problem of long time evolutions.\\

In this semiclassical setting \textit{Hagedorn} wavepackets with its operators as described in \cite{H_ladder_operators} is a viable tool to overcome these challenges. Not only will it be gridfree but also a spectral based method which results in fast approximations in space of localized wave-functions. Lastly it further allows highly oscillating functions.\\

%basic algorithmisch mit hagedorn 
%mit splitting methoden P Q p q klassische probagation 
%quantum corrections

%second generation algorithmus Grad + Hagedorn
%[62]
A basic algorithm of computing quantum mechanics with \textit{Hagedorn} is specified in \cite{FGL_semiclassical_dynamics}. In this algorithm splitting method is used to divide the problem into classical propagation of \{q,p,Q,P,S\} with quantum correction terms.
Further improvement was done in \cite{GH_convsemiclassical}.\\

%waveblocks python master arbeit R.Bour
%diversitaet
A diverse implementation was done in python \cite{B_master_thesis} where source code is available on github \cite{waveblocksnd}. This implementation further supports various propagators. Interesting applications of this code can be found in the project about tunneling dynamics \cite{GHJ_tunneling_spawning} and non-adiabatic transitions \cite{BGH_natac}.\\
%application of code
%tunneling dynamics Gradinaru
%non adiabatic 

%C++ beginning
As python is an interpreted language it is mostly not optimized for execution time. To circumvent this problem a C++ implementation is desired. Until now only the base functionality was transferred to C++. Hagedorn wavepackets was done in \cite{bt_michajab}, inner products in \cite{st_benedekv} and the potentials in \cite{bt_lionelm}. The current base implementation is available on github \cite{libwaveblocks}. In this project the goal was to enlarge the C++ code functionality with intelligent data serialization. This was done with the well-known HDF5 library to reach compatibility with the structure of the data of the two implementation. This further allowed to use the GoogleTest framework to write a test which enabled to check if two simulations with different implementations yield the same data.